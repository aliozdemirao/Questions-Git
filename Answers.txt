1. Git Nedir?

Git, Linus Torvalds tarafından geliştirilen ve 2005 yılında ilk kez duyurulan güçlü bir dağıtık versiyon kontrol sistemidir (DVCS). 
Linus Torvalds, özellikle Linux çekirdek geliştirme süreçlerini daha etkili ve verimli hale getirmek amacıyla Git'i oluşturdu. 
Bu sistem, kaynak kodu yönetiminde çığır açan bir esnekliğe sahiptir ve açık kaynak dünyasında geniş bir kullanıcı kitlesi tarafından benimsenmiştir. 
Git, yazılım geliştirme projelerinde, değişiklikleri titizlikle takip etmek, paralel geliştirmeleri kolaylaştırmak ve farklı geliştiriciler arasında sorunsuz işbirliği sağlamak için vazgeçilmez bir araçtır.
================================================



2. "git pull" ile "git fetch" komutlarının farkı nedir?

git pull ve git fetch komutları, uzak depodan (remote repository) güncellemeleri almak için kullanılan iki farklı Git komutudur.
İşlevsel olarak benzer gibi görünseler de, temelde farklı davranışlara sahiptirler.

git fetch:
git fetch, uzak depodan yeni verileri indirir ve bu verileri lokal depo ile eşler, ancak yerel deponuzdaki mevcut çalışma kopyasını değiştirmez.
Bu komut, uzak depodaki tüm branch'leri ve commit'leri indirir, ancak lokal depodaki herhangi bir branch'i veya commit'i değiştirmez.

git pull:
git pull, aslında git fetch komutunu çalıştırır ve ardından otomatik olarak mevcut çalışma kopyanızı (yerel branch'iniz) uzaktaki branch ile birleştirir.
Yani, git pull, git fetch ve ardından git merge (veya git rebase) işlemlerini otomatikleştirir.
git pull komutu, yeni verileri almak ve yerel çalışma kopyasını güncellemek istediğinizde kullanılır. Ancak, dikkat edilmelidir ki, bu komut yerel deponuzdaki değişiklikleri etkiler.

Genel olarak, eğer uzak depodaki değişiklikleri incelemek istiyorsanız ve birleştirme işlemi yapmak istemiyorsanız, git fetch kullanabilirsiniz.
Eğer uzak değişiklikleri alıp hemen lokalde birleştirmek istiyorsanız, git pull kullanabilirsiniz.
================================================



3. Eğer takım arkadaşımız "kodlarımı gönderdim, benim geliştirmemin üzerine devam et" derse ve gönderdiği kodları "git pull" ile lokalimize alamıyorsak nerelerde hata yapılmış olabilir?

git pull işleminin başarısız olma nedenleri çeşitlidir ve temelde iki ana sebep öne çıkmaktadır:
İlk olarak, takım arkadaşımızın kodlarını henüz GitHub'a push etmemiş olması.
Diğer bir potansiyel sorun, kodların farklı bir dalda bulunması ve git pull komutuyla doğru dalın çekilmemesidir.
================================================



4. "git fetch origin" komutundaki "origin" neye karşılık gelmektedir?

git fetch origin komutundaki "origin", uzak depoyu temsil eden bir kısaltmadır.
Bu uzak depo genellikle projenin orijinal kaynak deposudur.
Yani, git fetch origin komutu, bu uzak depodan gelen değişiklikleri sizin yerel depoya getirir, ancak birleştirme yapmaz. 
Yerel depo ile uzak depo arasındaki farkları görmek için kullanılır.
Ayrıca git remote -v komutu yerel depoya bağlı olan uzak depoların listesini ve bu depoların adreslerini gösterir.
================================================



5. "HEAD" kelimesi neyi temsil etmektedir?

HEAD, şu anda bulunduğumuz branch üzerindeki en son commit'i (hash'ini işaret eder) gösterir.
================================================



6. "Staging Area" ya da "Index" diye isimlendirilen bölge tam olarak ne demektir?

"Staging Area" veya "Index" olarak adlandırılan bölge, Git'in işlemlerinde önemli bir rol oynayan geçici bir depolama alanıdır. 
Bu bölge, değişiklikleri commit etmeden önce hazırlama (staging) aşamasını temsil eder.

İşleyiş şu şekildedir:

Yapılan değişiklikler ilk olarak working directory'de gerçekleşir.
Ardından, bu değişiklikler "Staging Area" adı verilen bu geçici alana eklenir (git add). 
Bu aşamada, Git'e hangi değişiklikleri commit etmek istediğinizi belirtmiş olursunuz.
Son olarak, "Staging Area" üzerindeki değişiklikler commit edilir (git commit) ve projenizin geçmişine eklenir.
================================================



7. "Untracked file" ne demektir?

"Untracked file" (İzlenmeyen dosya), Git'in takip etmediği veya izlemediği dosyaları ifade eder.
Bu dosyalar, projenin içinde bulunabilir, ancak Git, bu dosyaların değişikliklerini veya durumunu takip etmez.

Yeni bir dosya oluşturduğunuzda veya projeye eklediğiniz bir dosya olduğunda, bu dosya otomatik olarak "untracked" durumuna gelir. 
Git, bu dosyaları proje geçmişine dahil etmez, yani bu dosyalar bir commit'e dahil edilmez.

İşte bir örnek:

Yeni bir dosya oluşturduğunuzda veya mevcut bir dosyayı projeye eklediğinizde, bu dosya "untracked" durumunda olacaktır.
Dosyayı "staging area" veya "index" eklerseniz (git add kullanarak), dosya "tracked" durumuna gelir ve bu dosyanın değişiklikleri bir sonraki commit'e dahil edilebilir hale gelir.
Dosyayı bir commit ile kaydettiğinizde, artık bu dosya projenin geçmişinde izlenen bir dosya olur.
================================================



8. ".git" klasörünü silersek ne olur?

".git" klasörü, bir Git deposunun temel yapı taşlarını içeren kritik bir klasördür. 
Bu klasör, Git tarafından kullanılan meta verileri, commit geçmişi, branch bilgileri ve diğer depo ayarlarını içerir. 
Eğer ".git" klasörünü silerseniz, bu Git deposunun tüm geçmişi, branch'leri, commit'leri ve diğer Git ile ilgili bilgiler kaybolacaktır.
================================================



9. Kendi lokalimizde her "git init" komutunu kullanıdığımızda otomatik olarak "ReadMe.md" dosyası oluşturulmasını istiyorsak ne yapmalıyız?

"git init" komutu, yeni bir Git deposu oluşturur, ancak bu komut varsayılan olarak bir "ReadMe.md" dosyası oluşturmaz. 
Ancak, bu işlemi otomatikleştirmek için birkaç farklı yol bulunmaktadır. İşte birkaç öneri:


Temel bir Shell Komutu ile Oluşturma:

git init && echo "# My Project" > ReadMe.md
Bu komut, "git init" komutunu çalıştırdıktan sonra "ReadMe.md" dosyasını oluşturur.


Bir Bash Scripti Oluşturma:

# init-repo.sh
#!/bin/bash
git init
echo "# My Project" > ReadMe.md
Ardından bu scripti şu şekilde çalıştırabiliriz: bash init-repo.sh


Git Template Kullanma:

Git, yeni bir repo oluştururken belirli bir şablonu takip edebilir. 
Bu işlem için bir "template" dizini oluşturun ve içine varsayılan "ReadMe.md" dosyasını ekleyin.

mkdir ~/.git-templates
echo "# My Project" > ~/.git-templates/ReadMe.md
git config --global init.templatedir '~/.git-templates'
Bundan sonra her yeni repo oluşturduğunuzda, "ReadMe.md" dosyası otomatik olarak eklenir.
================================================



10. Git konusunda bahsi geçen "branch" yapısı nedir? Bize ne sağlar?

Git'teki "branch" (dal) yapısı, projenin farklı çalışma alanlarında bağımsız olarak gelişmesine ve değiştirilmesine olanak tanıyan bir özelliktir.
Bu, projenin farklı özelliklerinin veya düzeltmelerinin aynı anda geliştirilebileceği ve yönetilebileceği anlamına gelir.
Her bir dal, kendi bağımsız tarihçesine sahiptir, bu da projenin geçmişini izlemenizi ve belirli bir dal üzerindeki değişiklikleri diğer dallardan ayırmanızı sağlar.


Git'in "branch" yapısı şu temel prensipler üzerine kuruludur:

Ana Dal (Main Branch veya Master Branch): 
Projenin ana geliştirme hattını temsil eder. Genellikle "master" veya "main" adını alır. 
Bu dal, projenin genel ilerleyişini ve stabil sürümlerini temsil eder.

Yeni Özellik ve İyileştirmeler İçin Yeni Dallar: 
Yeni özellikler eklemek veya hata düzeltmek için yeni dallar oluşturabilirsiniz. 
Bu dallar, ana dalın bir kopyasıdır ve üzerlerinde yapılan değişikliklerin ana dala etkileşimi olmaz.

Dal Birleştirmeleri (Merging): 
Bir dal üzerindeki değişiklikleri ana dala birleştirmek, bu değişikliklerin projenin ana geliştirme hattına entegre edilmesini sağlar. 
Bu, projede tutarlı bir ilerleme ve uyum sağlar.


Branch yapısının avantajları şunlardır:

Paralel Çalışma: 
Birden fazla kişi aynı projede çalışırken, her biri kendi branch'inde çalışabilir. 
Bu, ekip üyelerinin birbirlerinin çalışmalarından etkilenmeden paralel olarak geliştirme yapmasına olanak tanır.

Risk Yönetimi: 
Yeni bir özellik veya değişiklik eklerken, bunu ana projenin mevcut sürümünden bağımsız olarak yapabilirsiniz. 
Eğer değişiklikler istenmeyen sonuçlar doğurursa, ana projeyi etkilemeden branch'i silerek geri dönebilirsiniz.

Deneme ve Geliştirme: 
Yeni özelliklerin veya değişikliklerin prototipini oluşturmak veya farklı yaklaşımları denemek için branch'ler kullanılabilir.
Bu sayede ana projeyi bozmadan farklı fikirleri test edebilirsiniz.

Sürüm Yönetimi: 
Farklı branch'ler, farklı sürümler veya yayınlar için kullanılabilir. 
Örneğin, "development", "release" veya "feature" adında farklı branch'ler oluşturabilir ve bu branch'ler aracılığıyla farklı sürümleri yönetebilirsiniz.

İzleme ve Yönetme: 
Her branch, üzerinde yapılan değişikliklerin tarihçesini ve geçmişini korur. 
Bu sayede, projenin farklı noktalarını inceleyebilir, geçmişte yapılan değişiklikleri görebilir ve gerektiğinde geri dönebilirsiniz.
================================================



11. Sıfırdan bir "branch" nasıl oluşturabiliriz?

git branch
Bu komut, Git deposundaki tüm branch'leri listeler. Aktif branch, üzerinde çalıştığınız branch, başında bir yıldız (*) ile gösterilir.

git branch feature-branch
Bu komut sadece branch'i oluşturur, ancak üzerine geçiş yapmaz.

git checkout -b feature-branch
Bu komut, branch'i oluşturur ve üzerine geçiş yapar.
================================================



12. Var olan bir "branch"e nasıl geçebiliriz?

git switch feature-branch
veya
git checkout feature-branch
komutları kullanır.
================================================



13. "git clone" komutunu kullanırken belirli bir spesifik branch'i sadece çekmek istiyorsak nasıl yapabiliriz?

git clone -b branch-adı repo-url
================================================



14. "Merge conflict" ne demektir?

Merge conflict (birleştirme çakışması), genellikle farklı kaynaklardan gelen değişikliklerin aynı satıra veya aynı dosyaya uygulandığı durumu ifade eder. 
Bu durum, Git'in otomatik olarak çözemediği bir durumdur ve manuel müdahale gerektirir.
================================================



15. "git log" komutu ile hangi bilgileri görebiliriz?

git log komutu, Git deposundaki commit geçmişini gösteren bir komuttur. 
Bu komut kullanıldığında, her bir commit ile ilgili aşağıdaki bilgileri görebilirsiniz:

Commit Hash (Kimlik): Her commitin benzersiz bir kimliği vardır. Bu kimlik, commit'in tam olarak tanımlanmasını sağlar.
Yazar Bilgisi: Kim tarafından yapıldığını gösteren yazar adı ve e-posta bilgisi.
Tarih ve Saat: Commit'in yapıldığı tarih ve saat bilgisi.
Commit Mesajı: Geliştirici tarafından yazılan açıklama veya not, commit mesajını temsil eder. Commit'in neyi değiştirdiğini veya eklediğini açıklar.

git log komutu, varsayılan olarak en yeni commit'ten başlayarak geçmişi gösterir. 
Ayrıca, farklı seçenekler ve filtreler kullanarak gösterilecek bilgileri ve sıralamayı özelleştirebilirsiniz. 
Örneğin, belirli bir dosyanın geçmişini görmek veya belirli bir tarih aralığındaki commit'leri incelemek gibi.
================================================



16. "git diff" ile kaç farklı iki durumun arasındaki değişiklikleri görebiliriz?

"git diff" komutu, iki durum (commit, branch, vs.) arasındaki değişiklikleri göstermek için kullanılır. 
Bu durumlar arasındaki değişiklikleri görmek için aşağıdaki kombinasyonları kullanabilirsiniz:

Working Directory ile Staging Area Arasındaki Değişiklikler: 
git diff
Bu komut, henüz staging area'ya eklenmemiş değişiklikleri gösterir.

Staging Area ile Son Commit Arasındaki Değişiklikler: 
git diff --staged
Bu komut, staging area'da bulunan ancak henüz commitlenmemiş değişiklikleri gösterir.

İki Commit Arasındaki Değişiklikler:
git diff commit1_sha commit2_sha
Bu komut, belirli iki commit arasındaki değişiklikleri gösterir.

Branchler Arasındaki Değişiklikler:
git diff branch1 branch2
Bu komut, iki branch arasındaki değişiklikleri gösterir.
================================================



17. Git reset ile neyi geri alıyoruz?

Staging Alanındaki Değişiklikleri Geri Almak:
git reset
Bu komut, sadece staging alanındaki değişiklikleri geri alır, working directory'deki değişiklikleri etkilemez.

Commit'leri Geri Almak:
git reset HEAD~1
Bu komut, HEAD'in bir önceki commit'e geri alır, ancak değişiklikleri working directory'de ve staging alanında bırakır.

Commit ve Değişiklikleri Geri Almak:
git reset --hard HEAD~1
Bu komut, HEAD'in bir önceki commit'e geri alır ve working directory'de ve staging alanında yapılan değişiklikleri tamamen siler.

Belirli Bir Commit'e Geri Almak:
git reset --hard commit_sha
Bu komut, belirli bir commit'e geri alır ve belirtilen commit'ten sonraki tüm commit'leri ve değişiklikleri siler.
================================================



18. "git commit" ile "git push" arasındaki fark nedir?

git commit:
git commit komutu, çalışma dizinindeki değişiklikleri bir commit olarak kaydetmek için kullanılır.
Yerel bir depoda gerçekleşen değişiklikleri kaydedip, commit mesajı ile birlikte bir geçmiş noktası oluşturur.
Commit, sadece yerel depoda yapılır ve henüz uzak depoya gönderilmemiştir.

git push:
git push komutu, yerel depodaki commit'leri uzak bir depoya göndermek için kullanılır.
Yapılan commit'leri uzak depo ile senkronize etmek ve diğer geliştiricilerle paylaşmak amacıyla kullanılır.
Bu komut, yerelde yapılan değişiklikleri uzak depoya "iter" ve paylaşır.

Özetle, git commit yerel depoda değişiklikleri kaydetmek için kullanılırken, git push bu yereldeki commit'leri uzak depoya göndermek ve paylaşmak için kullanılır.
================================================



19. Atomic commit ne demektir?

Atomic commit, yapılan commit'in birbirinden bağımsız ve bütünlük taşıyan küçük, özgün değişiklikleri içeren bir işlem olması anlamına gelir. 
Bu tür bir commit, uygulanan değişikliklerin birbirleriyle mantıklı bir şekilde gruplandığı ve bir bütün olarak kabul edilebilecek bir durumu temsil eder.

Atomic commit prensipleri şunları içerebilir:

Tek Bir Sorumluluk:
Her commit, sadece bir konsepti, özelliği veya sorumluluğu içermelidir. 
Birden fazla ve birbirinden bağımsız değişiklikler içeren commit'lerden kaçınılmalıdır.

Bütünlük:
Commit, bir projenin işlevselliğini veya bütünlüğünü bozmadan önceki durumu temsil etmelidir. 
Yarım kalmış, eksik veya hatalı commit'lerden kaçınılmalıdır.

Bağımsızlık:
Her commit, diğer commit'lerden bağımsız olmalıdır. 
Yani, bir commit'in başarılı olabilmesi için diğer commit'lerin tamamlanmış ve uygulanmış olmasına gerek olmamalıdır.

Atomic commit prensipleri, kod tabanının daha temiz, anlaşılır ve bakımı daha kolay olmasını sağlar. 
Ayrıca, ekip içinde işbirliğini artırabilir ve değişikliklerin geçmişini izlemeyi kolaylaştırır.
================================================



20. Repository ne demektir?

Repository, bir yazılım projesinin veya bir versiyon kontrol sisteminin merkezi depolama alanını ifade eder. Genellikle "repo" olarak kısaltılır. 
Bir repository, projenin kaynak kodu, dosyalar, geçmiş commit'leri ve projeyle ilgili diğer önemli bilgileri içerir.

Repository'ler, geliştiricilerin ve yazılım ekiplerinin bir araya gelerek projelerini yönetmelerini sağlar. Temel olarak iki tür repository vardır:

Lokal Repository:
Bilgisayarınızdaki fiziksel bir depodur.
Projenin tamamını veya bir kısmını içerir.
Genellikle geliştirme sırasında kullanılır.

Uzak (Remote) Repository:
Genellikle bir sunucuda bulunan merkezi bir depodur.
Birden çok geliştirici veya ekip üyesi, projenin bu uzak depo üzerinde senkronize bir şekilde çalışmasını sağlar.
Genellikle GitHub, GitLab, Bitbucket gibi platformlarda barınır.

Repository'ler, versiyon kontrol sistemleri (VCS) tarafından yönetilir. 
Git, Mercurial, Subversion gibi VCS'ler, projelerin geçmişini, değişiklikleri ve işbirliğini yönetmek için kullanılır ve bu VCS'ler genellikle bir repository'nin işleyişini sağlar.
================================================



21. "git tag" nedir? "git branch"’ten farkı nedir?

git tag:
"git tag" komutu, belirli bir commit'e bir etiket (tag) eklemek için kullanılır.
Etiketler, genellikle belirli bir sürümün veya önemli bir kilometre taşının temsil edildiği noktalarda kullanılır.
Etiketler, bir commit'in referansını daha anlamlı bir isimle ilişkilendirmek için kullanılır ve bu sayede o commit'e daha kolay erişim sağlar.

Farklar:
"git tag", belirli bir commit'e anlamlı bir isimle etiket eklerken, "git branch" yeni branch'ler oluşturmak ve mevcut branch'leri yönetmek için kullanılır.
Etiketler, genellikle sürümleri veya önemli yayınları temsil ederken, branch'ler paralel geliştirme veya farklı özellikler üzerinde çalışmayı temsil eder.
================================================